<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Neuron Project: Neuron Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Neuron Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classNeuron-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Neuron Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The unit cell of a network.  
 <a href="classNeuron.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="neuron_8hpp_source.html">neuron.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Neuron:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classNeuron.png" usemap="#Neuron_map" alt=""/>
  <map id="Neuron_map" name="Neuron_map">
<area href="classExcitatoryNeuron.html" title="A subclass of Neuron. " alt="ExcitatoryNeuron" shape="rect" coords="0,56,110,80"/>
<area href="classInhibitoryNeuron.html" title="A subclass of Neuron. " alt="InhibitoryNeuron" shape="rect" coords="120,56,230,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a823487d01615fadb8ac19a2768dd9d96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a823487d01615fadb8ac19a2768dd9d96"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#a823487d01615fadb8ac19a2768dd9d96">Neuron</a> ()</td></tr>
<tr class="memdesc:a823487d01615fadb8ac19a2768dd9d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constructor. <br/></td></tr>
<tr class="separator:a823487d01615fadb8ac19a2768dd9d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a250ce7e167760e593979b899745b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94a250ce7e167760e593979b899745b1"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#a94a250ce7e167760e593979b899745b1">~Neuron</a> ()</td></tr>
<tr class="memdesc:a94a250ce7e167760e593979b899745b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A destructor. <br/></td></tr>
<tr class="separator:a94a250ce7e167760e593979b899745b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86341dee7a81765fe4840777a008c688"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#a86341dee7a81765fe4840777a008c688">getMembranePotential</a> () const </td></tr>
<tr class="memdesc:a86341dee7a81765fe4840777a008c688"><td class="mdescLeft">&#160;</td><td class="mdescRight">A getter for the neuron's membrane potential.  <a href="#a86341dee7a81765fe4840777a008c688">More...</a><br/></td></tr>
<tr class="separator:a86341dee7a81765fe4840777a008c688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9497c01c1513b480cb96488e104c8b00"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#a9497c01c1513b480cb96488e104c8b00">getNumberOfSpikes</a> () const </td></tr>
<tr class="memdesc:a9497c01c1513b480cb96488e104c8b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">A getter for the number of times the neuron spiked in the course of time.  <a href="#a9497c01c1513b480cb96488e104c8b00">More...</a><br/></td></tr>
<tr class="separator:a9497c01c1513b480cb96488e104c8b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87bb09d99e4e9c2185be8b73fc242ba"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#ae87bb09d99e4e9c2185be8b73fc242ba">getSpikeTime</a> () const </td></tr>
<tr class="memdesc:ae87bb09d99e4e9c2185be8b73fc242ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">A getter for the neuron's spike times.  <a href="#ae87bb09d99e4e9c2185be8b73fc242ba">More...</a><br/></td></tr>
<tr class="separator:ae87bb09d99e4e9c2185be8b73fc242ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785f2fa8ab4f76dbc6a4b2a18c15da35"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#a785f2fa8ab4f76dbc6a4b2a18c15da35">getNumberOfTargets</a> () const </td></tr>
<tr class="memdesc:a785f2fa8ab4f76dbc6a4b2a18c15da35"><td class="mdescLeft">&#160;</td><td class="mdescRight">A getter of the number of targets the neuron has.  <a href="#a785f2fa8ab4f76dbc6a4b2a18c15da35">More...</a><br/></td></tr>
<tr class="separator:a785f2fa8ab4f76dbc6a4b2a18c15da35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6a80c21ff5172e4de00c7dbf706303"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#a3c6a80c21ff5172e4de00c7dbf706303">getNumberOfExcitatoryTargets</a> () const </td></tr>
<tr class="memdesc:a3c6a80c21ff5172e4de00c7dbf706303"><td class="mdescLeft">&#160;</td><td class="mdescRight">A getter of the number of excitatory neurons among the targets the neuron has.  <a href="#a3c6a80c21ff5172e4de00c7dbf706303">More...</a><br/></td></tr>
<tr class="separator:a3c6a80c21ff5172e4de00c7dbf706303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77210c7b0bf3739b01ec2e3dba96827"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#ae77210c7b0bf3739b01ec2e3dba96827">setInputCurrent</a> (double externalCurrent)</td></tr>
<tr class="memdesc:ae77210c7b0bf3739b01ec2e3dba96827"><td class="mdescLeft">&#160;</td><td class="mdescRight">A setter for the external input current.  <a href="#ae77210c7b0bf3739b01ec2e3dba96827">More...</a><br/></td></tr>
<tr class="separator:ae77210c7b0bf3739b01ec2e3dba96827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782b3b728eee5097ab205a7a7990225b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#a782b3b728eee5097ab205a7a7990225b">update</a> ()</td></tr>
<tr class="memdesc:a782b3b728eee5097ab205a7a7990225b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is invoked at each cycle of the simulation and makes the neutron evolve in the course of time.  <a href="#a782b3b728eee5097ab205a7a7990225b">More...</a><br/></td></tr>
<tr class="separator:a782b3b728eee5097ab205a7a7990225b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababbaa5bc5f7b2e00e0ae5ffcc8fbfdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#ababbaa5bc5f7b2e00e0ae5ffcc8fbfdb">updateWithoutBackgroundNoise</a> ()</td></tr>
<tr class="memdesc:ababbaa5bc5f7b2e00e0ae5ffcc8fbfdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The method is similar to void <a class="el" href="classNeuron.html#a782b3b728eee5097ab205a7a7990225b" title="Is invoked at each cycle of the simulation and makes the neutron evolve in the course of time...">update()</a> but it doesn't account for the random contribution from the rest of the brain. Is invoked at each cycle of the simulation and makes the neutron evolve in the course of time.  <a href="#ababbaa5bc5f7b2e00e0ae5ffcc8fbfdb">More...</a><br/></td></tr>
<tr class="separator:ababbaa5bc5f7b2e00e0ae5ffcc8fbfdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8111a347de6ddfb6c799bdcd3092cb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#aa8111a347de6ddfb6c799bdcd3092cb7">receiveSpike</a> (unsigned int localTimeOfSpikingNeuron, double spikeAmplitude)</td></tr>
<tr class="memdesc:aa8111a347de6ddfb6c799bdcd3092cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method of a connected neuron is called when the neuron spikes.  <a href="#aa8111a347de6ddfb6c799bdcd3092cb7">More...</a><br/></td></tr>
<tr class="separator:aa8111a347de6ddfb6c799bdcd3092cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf071c800e76fa7fbd611cee7cd76d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#a9bf071c800e76fa7fbd611cee7cd76d6">addTarget</a> (<a class="el" href="classNeuron.html">Neuron</a> *target)</td></tr>
<tr class="memdesc:a9bf071c800e76fa7fbd611cee7cd76d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a connection to a postsynaptic neuron, by adding it to its target.  <a href="#a9bf071c800e76fa7fbd611cee7cd76d6">More...</a><br/></td></tr>
<tr class="separator:a9bf071c800e76fa7fbd611cee7cd76d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5487631e8982ae2368da0917535a9001"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#a5487631e8982ae2368da0917535a9001">getBackgroundNoise</a> () const </td></tr>
<tr class="memdesc:a5487631e8982ae2368da0917535a9001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a value which accounts for the contribution of the rest of the brain.  <a href="#a5487631e8982ae2368da0917535a9001">More...</a><br/></td></tr>
<tr class="separator:a5487631e8982ae2368da0917535a9001"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac1a73d639befdae8610674bb66c15831"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#ac1a73d639befdae8610674bb66c15831">setRatioVextOverVthr</a> (double ratioVextOverVthr_)</td></tr>
<tr class="memdesc:ac1a73d639befdae8610674bb66c15831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter of the static attribute ratioVextOverVthr.  <a href="#ac1a73d639befdae8610674bb66c15831">More...</a><br/></td></tr>
<tr class="separator:ac1a73d639befdae8610674bb66c15831"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a521a967d65a078140cc9c6b8d30240ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#a521a967d65a078140cc9c6b8d30240ce">update</a> (void(Neuron::*membranePotentialUpdate)())</td></tr>
<tr class="memdesc:a521a967d65a078140cc9c6b8d30240ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">An auxiliary function that allows to avoid duplication of code in <a class="el" href="classNeuron.html#a782b3b728eee5097ab205a7a7990225b" title="Is invoked at each cycle of the simulation and makes the neutron evolve in the course of time...">update()</a> and <a class="el" href="classNeuron.html#ababbaa5bc5f7b2e00e0ae5ffcc8fbfdb" title="The method is similar to void update() but it doesn&#39;t account for the random contribution from the re...">updateWithoutBackgroundNoise()</a>.  <a href="#a521a967d65a078140cc9c6b8d30240ce">More...</a><br/></td></tr>
<tr class="separator:a521a967d65a078140cc9c6b8d30240ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a81d8527734e59bae39f73fece887f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#a41a81d8527734e59bae39f73fece887f">updateMembranePotential</a> ()</td></tr>
<tr class="memdesc:a41a81d8527734e59bae39f73fece887f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and sets the new membrane potential as a function of the current membrane potential, the spikes that arrived with a signal delay and the random background noise arriving from the rest of the brain.  <a href="#a41a81d8527734e59bae39f73fece887f">More...</a><br/></td></tr>
<tr class="separator:a41a81d8527734e59bae39f73fece887f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3d0130b76a6e1daa0191b97718178b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#a2a3d0130b76a6e1daa0191b97718178b">updateMembranePotentialWithoutBackgroundNoise</a> ()</td></tr>
<tr class="memdesc:a2a3d0130b76a6e1daa0191b97718178b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and sets the new membrane potential as a function of the current membrane potential, the external input current and the spikes that arrived with a signal delay.  <a href="#a2a3d0130b76a6e1daa0191b97718178b">More...</a><br/></td></tr>
<tr class="separator:a2a3d0130b76a6e1daa0191b97718178b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40fbb2b025efb1db420da32e16741c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#aa40fbb2b025efb1db420da32e16741c1">isRefractory</a> () const </td></tr>
<tr class="memdesc:aa40fbb2b025efb1db420da32e16741c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the neuron's internal time to the time of the last spike and the refraction time in order to test if the neuron is in a refractory period.  <a href="#aa40fbb2b025efb1db420da32e16741c1">More...</a><br/></td></tr>
<tr class="separator:aa40fbb2b025efb1db420da32e16741c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955ecfd2984f75c18664bd370c34af1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#a955ecfd2984f75c18664bd370c34af1d">spike</a> ()</td></tr>
<tr class="memdesc:a955ecfd2984f75c18664bd370c34af1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the spiking time and sets the membrane potential to zero and sends an electrical impulse to the connected neurons.  <a href="#a955ecfd2984f75c18664bd370c34af1d">More...</a><br/></td></tr>
<tr class="separator:a955ecfd2984f75c18664bd370c34af1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763493ef8eff51a638cbb75f0983b828"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#a763493ef8eff51a638cbb75f0983b828">readRingBuffer</a> () const </td></tr>
<tr class="memdesc:a763493ef8eff51a638cbb75f0983b828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the ring buffer's current entry to receive the spikes arriving with a delay that where emmited by presynaptic neurons.  <a href="#a763493ef8eff51a638cbb75f0983b828">More...</a><br/></td></tr>
<tr class="separator:a763493ef8eff51a638cbb75f0983b828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dd9577d84a48bd427201b4b8234150"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#a41dd9577d84a48bd427201b4b8234150">reinitializeCurrentRingBufferElement</a> ()</td></tr>
<tr class="memdesc:a41dd9577d84a48bd427201b4b8234150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current ring buffer element to zero and makes it thus ready to record new arriving spikes in another cycle to come.  <a href="#a41dd9577d84a48bd427201b4b8234150">More...</a><br/></td></tr>
<tr class="separator:a41dd9577d84a48bd427201b4b8234150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c7b80b5e70e906734ce710d37b1fd7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#af1c7b80b5e70e906734ce710d37b1fd7">timeToRingBufferIndex</a> (unsigned int time) const </td></tr>
<tr class="memdesc:af1c7b80b5e70e906734ce710d37b1fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxilliary method that yields the associated ring buffer index to a a given time by means of the modulo operator and checks if it is licit.  <a href="#af1c7b80b5e70e906734ce710d37b1fd7">More...</a><br/></td></tr>
<tr class="separator:af1c7b80b5e70e906734ce710d37b1fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2283fbfaba764cd088e6d16b0a74bb"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#aec2283fbfaba764cd088e6d16b0a74bb">getSpikeAmplitude</a> () const </td></tr>
<tr class="memdesc:aec2283fbfaba764cd088e6d16b0a74bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A virtual method which returns the constant spike amplitude, that differs between inhibitory and excitatory neurons.  <a href="#aec2283fbfaba764cd088e6d16b0a74bb">More...</a><br/></td></tr>
<tr class="separator:aec2283fbfaba764cd088e6d16b0a74bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a311f3321f19462c0aef8cbd68c60df67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a311f3321f19462c0aef8cbd68c60df67"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#a311f3321f19462c0aef8cbd68c60df67">membranePotential</a></td></tr>
<tr class="memdesc:a311f3321f19462c0aef8cbd68c60df67"><td class="mdescLeft">&#160;</td><td class="mdescRight">The neuron's most important variable, a double. <br/></td></tr>
<tr class="separator:a311f3321f19462c0aef8cbd68c60df67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50505e8dcb655170bfc9562465fd907f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50505e8dcb655170bfc9562465fd907f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#a50505e8dcb655170bfc9562465fd907f">inputCurrent</a></td></tr>
<tr class="memdesc:a50505e8dcb655170bfc9562465fd907f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The external current that is applied to the neuron, a double, is zero if not altered in the main using its the setter. <br/></td></tr>
<tr class="separator:a50505e8dcb655170bfc9562465fd907f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab358994e1a6e4d3a1399906471657b4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab358994e1a6e4d3a1399906471657b4b"></a>
std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#ab358994e1a6e4d3a1399906471657b4b">spikes</a></td></tr>
<tr class="memdesc:ab358994e1a6e4d3a1399906471657b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container that stores the spiking times in the course of time, a vector !!!!!!is not the appropriate choice...a list would provide the required functions as well. <br/></td></tr>
<tr class="separator:ab358994e1a6e4d3a1399906471657b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c97843cd38dd8c5ff2d861d25e18473"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c97843cd38dd8c5ff2d861d25e18473"></a>
std::vector&lt; <a class="el" href="classNeuron.html">Neuron</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#a5c97843cd38dd8c5ff2d861d25e18473">targets</a></td></tr>
<tr class="memdesc:a5c97843cd38dd8c5ff2d861d25e18473"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container containing the postsynaptic neurons, the neurons on which an eventual spike of the current neuron has an impact. <br/></td></tr>
<tr class="separator:a5c97843cd38dd8c5ff2d861d25e18473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1a016b5d339ba3ba95367bb66f391a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#adb1a016b5d339ba3ba95367bb66f391a">internalTime</a></td></tr>
<tr class="memdesc:adb1a016b5d339ba3ba95367bb66f391a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Another clock which allows to synchronize the times between the neurons, otherwise a problem arises when it comes to distinguishing between alrady updated and not yet updated neurons in neuron interactions.  <a href="#adb1a016b5d339ba3ba95367bb66f391a">More...</a><br/></td></tr>
<tr class="separator:adb1a016b5d339ba3ba95367bb66f391a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15160c28823ad0e63f171af31fd6b1ea"><td class="memItemLeft" align="right" valign="top">std::array&lt; double, <br class="typebreak"/>
SIGNAL_DELAY_D+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#a15160c28823ad0e63f171af31fd6b1ea">incomingSpikes</a></td></tr>
<tr class="memdesc:a15160c28823ad0e63f171af31fd6b1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array containing one more element than the uniform signal delay which allows to record all the incoming spike amplitudes and them being read at the right time.  <a href="#a15160c28823ad0e63f171af31fd6b1ea">More...</a><br/></td></tr>
<tr class="separator:a15160c28823ad0e63f171af31fd6b1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a1b5bf86e2ff7636a7e944909e19ec0f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b5bf86e2ff7636a7e944909e19ec0f6"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeuron.html#a1b5bf86e2ff7636a7e944909e19ec0f6">ratioVextOverVthr</a></td></tr>
<tr class="memdesc:a1b5bf86e2ff7636a7e944909e19ec0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A value determining the frequency of spikes from the rest of the brain. <br/></td></tr>
<tr class="separator:a1b5bf86e2ff7636a7e944909e19ec0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The unit cell of a network. </p>
<p>A neuron evolves over time, its membrane potential reacts to external stimuli and it can itself send electrical signals to connected neurons. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9bf071c800e76fa7fbd611cee7cd76d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Neuron::addTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNeuron.html">Neuron</a> *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a connection to a postsynaptic neuron, by adding it to its target. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classNetwork.html#a0f7791473e2dab1ed23d0af25e3c866d" title="Auxiliary function that creates the connections between neurons. ">Network::establishConnections()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>a pointer to a neuron that shall receive signals </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5487631e8982ae2368da0917535a9001"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Neuron::getBackgroundNoise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a value which accounts for the contribution of the rest of the brain. </p>
<p>This contribution is modeled by Cext excitatory neurons that fire randomly according to a poisson distribution at a frequency vext. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classNeuron.html#a41a81d8527734e59bae39f73fece887f" title="Calculates and sets the new membrane potential as a function of the current membrane potential...">updateMembranePotential()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a randomly generated value representing the background noise coming from the rest of the brain, a double </dd></dl>

</div>
</div>
<a class="anchor" id="a86341dee7a81765fe4840777a008c688"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Neuron::getMembranePotential </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A getter for the neuron's membrane potential. </p>
<dl class="section return"><dt>Returns</dt><dd>the neuron's membrane potential, a double </dd></dl>

</div>
</div>
<a class="anchor" id="a3c6a80c21ff5172e4de00c7dbf706303"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Neuron::getNumberOfExcitatoryTargets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A getter of the number of excitatory neurons among the targets the neuron has. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classNetwork.html#a2f3ab248d3453b67f1545bf2e310538f" title="Goes through the network&#39;s neurons and calculates the mean number of excitatory targets per neuron...">Network::getMeanNumberOfExcitatoryTargetsPerNeuron</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of excitatory neurons among the targets the neuron has, an unsigned int </dd></dl>

</div>
</div>
<a class="anchor" id="a9497c01c1513b480cb96488e104c8b00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Neuron::getNumberOfSpikes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A getter for the number of times the neuron spiked in the course of time. </p>
<p>Serves in testing. Uses the size of the vector storing the spike times. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of times the neuon spiked, a size_t </dd></dl>

</div>
</div>
<a class="anchor" id="a785f2fa8ab4f76dbc6a4b2a18c15da35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Neuron::getNumberOfTargets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A getter of the number of targets the neuron has. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classNetwork.html#a2e2531cb63d1b17bd4ce29a675b12d74" title="Goes through the network&#39;s neurons and calculates the mean number of targets per neuron. ">Network::getMeanNumberOfTargetsPerNeuron</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of targets the neuron has, an unsigned int </dd></dl>

</div>
</div>
<a class="anchor" id="aec2283fbfaba764cd088e6d16b0a74bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Neuron::getSpikeAmplitude </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A virtual method which returns the constant spike amplitude, that differs between inhibitory and excitatory neurons. </p>
<p>(The method is defined for unspecified neurons as well so that the tests of previous versions of the program are still functional, otherwise it could be virtual pure.). </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classNeuron.html#a41a81d8527734e59bae39f73fece887f" title="Calculates and sets the new membrane potential as a function of the current membrane potential...">updateMembranePotential()</a> </dd>
<dd>
<a class="el" href="classNeuron.html#a2a3d0130b76a6e1daa0191b97718178b" title="Calculates and sets the new membrane potential as a function of the current membrane potential...">updateMembranePotentialWithoutBackgroundNoise()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the spike amplitudes of the presynaptic neuron, a double </dd></dl>

<p>Reimplemented in <a class="el" href="classInhibitoryNeuron.html#a762e2b7bcf64962f764031d991911b7a">InhibitoryNeuron</a>, and <a class="el" href="classExcitatoryNeuron.html#ab0ee5f76af48d48de6c42b1f5b27142a">ExcitatoryNeuron</a>.</p>

</div>
</div>
<a class="anchor" id="ae87bb09d99e4e9c2185be8b73fc242ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt; unsigned int &gt; &amp; Neuron::getSpikeTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A getter for the neuron's spike times. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classNetwork.html#ac82435bb56bf5eabfdd3e3f4afadea2b" title="Calculates the mean spike rate of the network&#39;s neurons in an interval to indicate. ">Network::getMeanSpikeRateInInterval</a> </dd>
<dd>
<a class="el" href="classNetwork.html#a704f86bb8fc175c204aa63575116b33a" title="An auxiliary function for printing the network&#39;s spike times to a file that returns an iterator point...">Network::getIteratorToBeginInterval</a> </dd>
<dd>
<a class="el" href="classNetwork.html#aa8c6b4953e1c5655d891859ffd936848" title="An auxiliary function for printing the network&#39;s spike times to a file that returns an iterator point...">Network::getIteratorToEndInterval</a> </dd>
<dd>
<a class="el" href="classNetwork.html#a92fcc003c80ba7657389c500d7b9a0c1" title="An auxiliary function for printing the network&#39;s spike times to a file that returns an iterator point...">Network::getIteratorToBegin</a> </dd>
<dd>
<a class="el" href="classNetwork.html#a9d5998fdbac5347ebd70936dfaf7b47c" title="An auxiliary function for printing the network&#39;s spike times to a file that returns an iterator point...">Network::getIteratorToEnd</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the neuron's spiking times in simulation steps, a const reference to a vector of unsigned integers </dd></dl>

</div>
</div>
<a class="anchor" id="aa40fbb2b025efb1db420da32e16741c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Neuron::isRefractory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the neuron's internal time to the time of the last spike and the refraction time in order to test if the neuron is in a refractory period. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classNeuron.html#a782b3b728eee5097ab205a7a7990225b" title="Is invoked at each cycle of the simulation and makes the neutron evolve in the course of time...">update</a>(void (<a class="el" href="classNeuron.html" title="The unit cell of a network. ">Neuron</a>::*membranePotentialUpdate)()) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>if the neuron is in a refractory state, a bool </dd></dl>

</div>
</div>
<a class="anchor" id="a763493ef8eff51a638cbb75f0983b828"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Neuron::readRingBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the ring buffer's current entry to receive the spikes arriving with a delay that where emmited by presynaptic neurons. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classNeuron.html#a41a81d8527734e59bae39f73fece887f" title="Calculates and sets the new membrane potential as a function of the current membrane potential...">updateMembranePotential()</a> </dd>
<dd>
<a class="el" href="classNeuron.html#a2a3d0130b76a6e1daa0191b97718178b" title="Calculates and sets the new membrane potential as a function of the current membrane potential...">updateMembranePotentialWithoutBackgroundNoise()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of spike amplitudes of spikes from connected neurons that are currently arriving, a double </dd></dl>

</div>
</div>
<a class="anchor" id="aa8111a347de6ddfb6c799bdcd3092cb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Neuron::receiveSpike </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>localTimeOfSpikingNeuron</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>spikeAmplitude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method of a connected neuron is called when the neuron spikes. </p>
<p>The spike gets stored in its ring buffer in order to be read at the appropriate time. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classNeuron.html#a955ecfd2984f75c18664bd370c34af1d" title="Stores the spiking time and sets the membrane potential to zero and sends an electrical impulse to th...">spike()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">localTimeOfSpikingNeuron</td><td>an unsigned integer </td></tr>
    <tr><td class="paramname">spikeAmplitude</td><td>defining the strength of the signal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the neuron is in a refractory state, a bool </dd></dl>

</div>
</div>
<a class="anchor" id="a41dd9577d84a48bd427201b4b8234150"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Neuron::reinitializeCurrentRingBufferElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the current ring buffer element to zero and makes it thus ready to record new arriving spikes in another cycle to come. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classNeuron.html#a782b3b728eee5097ab205a7a7990225b" title="Is invoked at each cycle of the simulation and makes the neutron evolve in the course of time...">update</a>(void (<a class="el" href="classNeuron.html" title="The unit cell of a network. ">Neuron</a>::*membranePotentialUpdate)()) </dd></dl>

</div>
</div>
<a class="anchor" id="ae77210c7b0bf3739b01ec2e3dba96827"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Neuron::setInputCurrent </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>externalCurrent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A setter for the external input current. </p>
<p>A method allowing to simulate the stimulation of the neuron by an external current. Is invoked in the main loop of the simulation in order to indicate the strength of the external stimulus. Not required any more in the final version of the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">externalCurrent</td><td>the external input current a double. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1a73d639befdae8610674bb66c15831"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Neuron::setRatioVextOverVthr </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ratioVextOverVthr_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setter of the static attribute ratioVextOverVthr. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classSimulation.html#a9c9a1b5e52b447c84977990ebd545f38" title="An auxiliary method in order to modularize the code. ">Simulation::run()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a955ecfd2984f75c18664bd370c34af1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Neuron::spike </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the spiking time and sets the membrane potential to zero and sends an electrical impulse to the connected neurons. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classNeuron.html#a782b3b728eee5097ab205a7a7990225b" title="Is invoked at each cycle of the simulation and makes the neutron evolve in the course of time...">update</a>(void (<a class="el" href="classNeuron.html" title="The unit cell of a network. ">Neuron</a>::*membranePotentialUpdate)()) </dd></dl>

</div>
</div>
<a class="anchor" id="af1c7b80b5e70e906734ce710d37b1fd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Neuron::timeToRingBufferIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auxilliary method that yields the associated ring buffer index to a a given time by means of the modulo operator and checks if it is licit. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classNeuron.html#aa8111a347de6ddfb6c799bdcd3092cb7" title="This method of a connected neuron is called when the neuron spikes. ">receiveSpike()</a> </dd>
<dd>
<a class="el" href="classNeuron.html#a763493ef8eff51a638cbb75f0983b828" title="Reads the ring buffer&#39;s current entry to receive the spikes arriving with a delay that where emmited ...">readRingBuffer()</a> </dd>
<dd>
<a class="el" href="classNeuron.html#a41dd9577d84a48bd427201b4b8234150" title="Sets the current ring buffer element to zero and makes it thus ready to record new arriving spikes in...">reinitializeCurrentRingBufferElement()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>the time of which one wants to know the corresponding ring buffer index an unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ring buffer index corresponding to the given time a size_t </dd></dl>

</div>
</div>
<a class="anchor" id="a782b3b728eee5097ab205a7a7990225b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Neuron::update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is invoked at each cycle of the simulation and makes the neutron evolve in the course of time. </p>
<p>Advances the neuron one step as a function of its current state by eventual spiking if the membrane potential has reached a threshold, resting inactive during the refractory period after a spike or updating the membrane potential and finally handling the ring buffer and the random contribution from the rest of the brain as well as incrementing the neuron's internal clock. Makes use of the function void update(void (<a class="el" href="classNeuron.html" title="The unit cell of a network. ">Neuron</a>::*membranePotentialUpdate)()) in order to avoid duplication of code. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classNetwork.html#ab07bb6f6d9020b9eb230551083ea929f" title="A method updating all of the network&#39;s neuron by one step which is used in the main loop...">Network::update()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a521a967d65a078140cc9c6b8d30240ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Neuron::update </td>
          <td>(</td>
          <td class="paramtype">void(Neuron::*)()&#160;</td>
          <td class="paramname"><em>membranePotentialUpdate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An auxiliary function that allows to avoid duplication of code in <a class="el" href="classNeuron.html#a782b3b728eee5097ab205a7a7990225b" title="Is invoked at each cycle of the simulation and makes the neutron evolve in the course of time...">update()</a> and <a class="el" href="classNeuron.html#ababbaa5bc5f7b2e00e0ae5ffcc8fbfdb" title="The method is similar to void update() but it doesn&#39;t account for the random contribution from the re...">updateWithoutBackgroundNoise()</a>. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classNeuron.html#a782b3b728eee5097ab205a7a7990225b" title="Is invoked at each cycle of the simulation and makes the neutron evolve in the course of time...">update()</a> </dd>
<dd>
<a class="el" href="classNeuron.html#ababbaa5bc5f7b2e00e0ae5ffcc8fbfdb" title="The method is similar to void update() but it doesn&#39;t account for the random contribution from the re...">updateWithoutBackgroundNoise()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">membranePotentialUpdate</td><td>a member function without return value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a41a81d8527734e59bae39f73fece887f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Neuron::updateMembranePotential </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and sets the new membrane potential as a function of the current membrane potential, the spikes that arrived with a signal delay and the random background noise arriving from the rest of the brain. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classNeuron.html#a782b3b728eee5097ab205a7a7990225b" title="Is invoked at each cycle of the simulation and makes the neutron evolve in the course of time...">update()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2a3d0130b76a6e1daa0191b97718178b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Neuron::updateMembranePotentialWithoutBackgroundNoise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and sets the new membrane potential as a function of the current membrane potential, the external input current and the spikes that arrived with a signal delay. </p>
<p>Similar to <a class="el" href="classNeuron.html#a41a81d8527734e59bae39f73fece887f" title="Calculates and sets the new membrane potential as a function of the current membrane potential...">updateMembranePotential()</a> but not considering the random background noise arriving from the rest of the brain, but an external current instead. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classNeuron.html#ababbaa5bc5f7b2e00e0ae5ffcc8fbfdb" title="The method is similar to void update() but it doesn&#39;t account for the random contribution from the re...">updateWithoutBackgroundNoise()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ababbaa5bc5f7b2e00e0ae5ffcc8fbfdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Neuron::updateWithoutBackgroundNoise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The method is similar to void <a class="el" href="classNeuron.html#a782b3b728eee5097ab205a7a7990225b" title="Is invoked at each cycle of the simulation and makes the neutron evolve in the course of time...">update()</a> but it doesn't account for the random contribution from the rest of the brain. Is invoked at each cycle of the simulation and makes the neutron evolve in the course of time. </p>
<p>Advances the neuron one step as a function of its current state by eventual spiking if the membrane potential has reached a threshold, resting inactive during the refractory period after a spike or updating the membrane potential and finally handling the ring buffer as well as incrementing the neuron's internal clock. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a15160c28823ad0e63f171af31fd6b1ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;double, SIGNAL_DELAY_D + 1&gt; Neuron::incomingSpikes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An array containing one more element than the uniform signal delay which allows to record all the incoming spike amplitudes and them being read at the right time. </p>
<p>A ring buffer ensuring spikes arrive with the right signal delay, an array of doubles. </p>

</div>
</div>
<a class="anchor" id="adb1a016b5d339ba3ba95367bb66f391a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Neuron::internalTime</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Another clock which allows to synchronize the times between the neurons, otherwise a problem arises when it comes to distinguishing between alrady updated and not yet updated neurons in neuron interactions. </p>
<p>A clock keeping track of the neuron's local time, an unsigned integer. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="neuron_8hpp_source.html">neuron.hpp</a></li>
<li>neuron.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Nov 11 2017 18:58:28 for Neuron Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
